// Generated by CoffeeScript 1.10.0
(function() {
  var slice = [].slice;

  this.SeapigRouter = (function() {
    function SeapigRouter(seapig_client, options) {
      var code, commit_scheduled_at, commit_timer, i, location_update, priv, remote_state, session_data, session_data_saved, state_description_to_url, state_diff_apply, state_diff_generate, state_get_as_state_description, state_permanent, state_set_from_state_description, url_to_state_description;
      if (options == null) {
        options = {};
      }
      this.seapig_client = seapig_client;
      this.session_id = void 0;
      this.mountpoint = options.mountpoint || "/";
      this.default_state = options["default"] || {};
      this.debug = options.debug;
      this.expose = options.expose || [];
      this.cast = options.cast || function(state) {
        return state;
      };
      this.onsessionopen = options.onsessionopen;
      this.token = ((function() {
        var l, len, ref, results;
        ref = (function() {
          var m, results1;
          results1 = [];
          for (i = m = 0; m <= 11; i = ++m) {
            results1.push(Math.floor(Math.random() * 62));
          }
          return results1;
        })();
        results = [];
        for (l = 0, len = ref.length; l < len; l++) {
          code = ref[l];
          results.push(String.fromCharCode(48 + code + (code > 9 ? 7 : 0) + (code > 35 ? 6 : 0)));
        }
        return results;
      })()).join("");
      if (this.debug) {
        console.log('ROUTER: Generated token: ', this.token);
      }
      this.state = void 0;
      this.state_id = 1;
      this.state_raw = {
        session_id: void 0,
        state_id: 0,
        state_parent: void 0,
        state_committed: true
      };
      this.state_valid = false;
      commit_scheduled_at = null;
      commit_timer = null;
      remote_state = null;
      priv = {};
      if (options.expose_privates) {
        this["private"] = priv;
      }
      session_data = this.seapig_client.master('SeapigRouter::Session::' + this.token + '::Data', {
        object: {
          token: this.token,
          session: this.session_id,
          states: {}
        }
      });
      session_data.bump();
      session_data_saved = this.seapig_client.slave('SeapigRouter::Session::' + this.token + '::Saved');
      session_data_saved.onchange((function(_this) {
        return function() {
          var l, len, ref, state_id;
          if (!session_data_saved.valid) {
            return;
          }
          ref = _.keys(session_data.object.states);
          for (l = 0, len = ref.length; l < len; l++) {
            state_id = ref[l];
            if (parseInt(state_id) < session_data_saved.object.max_state_id) {
              delete session_data.object.states[state_id];
            }
          }
          if (_this.session_id == null) {
            _this.session_id = session_data_saved.object.session_id;
            if ((_this.state != null) && (_this.state_raw.session_id == null)) {
              _this.state.session_id = _this.state_raw.session_id = _this.session_id;
            }
            if (_this.debug) {
              console.log('ROUTER: Session opened', _this.session_id);
            }
            if (_this.onsessionopen != null) {
              _this.onsessionopen(_this.session_id);
            }
          }
          if (_this.debug) {
            console.log('ROUTER: Session saved up till:', session_data_saved.object.max_state_id);
          }
          if (_this.state_valid) {
            return location_update(false);
          }
        };
      })(this));
      document.onclick = (function(_this) {
        return function(event) {
          var href;
          href = event.target.getAttribute("href") || "";
          if (_this.debug) {
            console.log('ROUTER: A-element clicked, changing location to:', href);
          }
          if (!(href[0] === '?')) {
            return true;
          }
          _this.navigate(href);
          return false;
        };
      })(this);
      window.onpopstate = (function(_this) {
        return function(event) {
          var previous_state;
          previous_state = _this.state_raw;
          _this.state_raw = JSON.parse(JSON.stringify(event.state));
          if (_this.state_raw.session_id == null) {
            _this.state_raw.session_id = _this.session_id;
          }
          _this.state = _this.cast(JSON.parse(JSON.stringify(_this.state_raw)));
          if (_this.debug) {
            console.log('ROUTER: History navigation triggered. Going to:', event.state);
          }
          location_update(false);
          if (_this.onchange != null) {
            return _this.onchange(_this.state_raw, previous_state);
          }
        };
      })(this);
      state_permanent = (function(_this) {
        return function(state) {
          return _.omit(state, function(value, key) {
            return key.indexOf("_") === 0 || key === "session_id" || key === "state_id" || key === "state_parent" || key === "state_committed";
          });
        };
      })(this);
      state_diff_generate = priv.state_diff_generate = (function(_this) {
        return function(state1, state2) {
          var array_diff, element_diff, object_diff;
          element_diff = function(diff, address, object1, object2) {
            var same_type;
            same_type = (typeof object1 === typeof object2) && (Array.isArray(object1) === Array.isArray(object2));
            if ((object2 == null) || ((object1 != null) && !same_type)) {
              diff.push(['-' + address, '-']);
              object1 = void 0;
            }
            if (Array.isArray(object2)) {
              return array_diff(diff, address + "~", object1 || [], object2);
            } else if (typeof object2 === 'object') {
              return object_diff(diff, address + ".", object1 || {}, object2);
            } else if (object2 != null) {
              if (object1 !== object2) {
                return diff.push([address, object2]);
              }
            }
          };
          object_diff = function(diff, address, object1, object2) {
            var key, l, len, ref;
            ref = _.uniq(_.union(_.keys(object1), _.keys(object2)));
            for (l = 0, len = ref.length; l < len; l++) {
              key = ref[l];
              element_diff(diff, address + key, object1[key], object2[key]);
            }
            return diff;
          };
          array_diff = function(diff, address, array1, array2) {
            var element1, j, k, l, len, results;
            j = 0;
            for (i = l = 0, len = array1.length; l < len; i = ++l) {
              element1 = array1[i];
              if (_.isEqual(element1, array2[j])) {
                j++;
              } else {
                k = j;
                while ((!_.isEqual(element1, array2[k])) && (k < array2.length)) {
                  k++;
                }
                if (k === array2.length) {
                  if (typeof element1 === 'object') {
                    diff.push(["-" + address + j + "~", "-"]);
                  } else {
                    diff.push(["-" + address + "~", element1]);
                  }
                } else {
                  while (j < k) {
                    element_diff(diff, address + j + "~", void 0, array2[j++]);
                  }
                  j++;
                }
              }
            }
            results = [];
            while (j < array2.length) {
              results.push(element_diff(diff, address + "~", void 0, array2[j++]));
            }
            return results;
          };
          return object_diff([], "", state1, state2);
        };
      })(this);
      state_diff_apply = priv.state_diff_apply = (function(_this) {
        return function(state, diff) {
          var add, address, entry, hash, index, l, len, len1, m, new_obj, obj, spl, subobj, value;
          for (l = 0, len = diff.length; l < len; l++) {
            entry = diff[l];
            address = entry[0];
            value = entry[1];
            add = address[0] !== '-';
            if (address[0] === '-') {
              address = address.slice(1);
            }
            obj = state;
            spl = address.split('.');
            for (i = m = 0, len1 = spl.length; m < len1; i = ++m) {
              subobj = spl[i];
              if (i < (spl.length - 1)) {
                if (subobj[subobj.length - 1] === '~') {
                  if (subobj.split("~")[1].length > 0) {
                    if (!obj[parseInt(subobj.split("~")[1])]) {
                      obj[parseInt(subobj.split("~")[1])] = {};
                    }
                    obj = obj[parseInt(subobj.split("~")[1])];
                  } else {
                    obj[subobj.split("~")[0]] = [new_obj = {}];
                    obj = new_obj;
                  }
                } else {
                  if (obj[subobj] == null) {
                    obj[subobj] = {};
                  }
                  obj = obj[subobj];
                }
              }
            }
            address = spl[spl.length - 1];
            hash = address[address.length - 1] !== '~';
            index = void 0;
            if ((!hash) && address.split("~")[1].length > 0) {
              index = parseInt(address.split('~')[1]);
            }
            address = address.split("~")[0];
            if (add) {
              if (hash) {
                obj[address] = value;
              } else {
                if (index != null) {
                  (obj[address] || (obj[address] = [])).splice(index, 0, value);
                } else {
                  (obj[address] || (obj[address] = [])).push(value);
                }
              }
            } else {
              if (hash) {
                delete obj[address];
              } else {
                if (index != null) {
                  obj[address].splice(index, 1);
                } else {
                  obj[address].splice(_.indexOf(obj[address], value), 1);
                }
              }
            }
          }
          return state;
        };
      })(this);
      url_to_state_description = (function(_this) {
        return function(pathname, search) {
          var component, decoded_pair, key, l, len, pair, part, ref, spl, state_description, version;
          state_description = {
            session_id: null,
            state_id: null,
            buffer: [],
            exposed: [],
            change: []
          };
          spl = pathname.split(_this.mountpoint);
          spl.shift();
          spl = (function() {
            var l, len, ref, results;
            ref = spl.join(this.mountpoint).split('/');
            results = [];
            for (l = 0, len = ref.length; l < len; l++) {
              part = ref[l];
              results.push(decodeURIComponent(part));
            }
            return results;
          }).call(_this);
          version = spl.shift();
          if (version === 'a') {
            state_description.session_id = spl.shift();
            if (state_description.session_id === '_') {
              state_description.session_id = void 0;
            }
            state_description.state_id = spl.shift();
          }
          if (state_description.state_id != null) {
            while (spl.length > 0) {
              key = spl.shift();
              if (key === '-') {
                break;
              }
              component = _.find(_this.expose, function(component) {
                return component[1];
              });
              if (!component) {
                next;
              }
              state_description.exposed.push([component[0], spl.shift()]);
            }
            while (spl.length > 0) {
              state_description.buffer.push([spl.shift(), spl.shift()]);
            }
          } else {
            state_description.session_id = _this.session_id;
            state_description.state_id = 0;
            state_description.buffer = state_diff_generate(state_permanent(_this.state_raw), state_permanent(_this.default_state));
          }
          if (search.length > 1) {
            ref = search.split('?')[1].split('&');
            for (l = 0, len = ref.length; l < len; l++) {
              pair = ref[l];
              decoded_pair = (function() {
                var len1, m, ref1, results;
                ref1 = pair.split('=', 2);
                results = [];
                for (m = 0, len1 = ref1.length; m < len1; m++) {
                  part = ref1[m];
                  results.push(decodeURIComponent(part));
                }
                return results;
              })();
              state_description.change.push(decoded_pair);
            }
          }
          if (_this.debug) {
            console.log('ROUTER: Parsed location', state_description);
          }
          return state_description;
        };
      })(this);
      state_description_to_url = (function(_this) {
        return function(state_description) {
          var component, url;
          if (_this.debug) {
            console.log('ROUTER: Calculating url for state description:', state_description);
          }
          url = _this.mountpoint + 'a/' + (state_description.session_id || '_') + '/' + state_description.state_id;
          if (state_description.exposed.length > 0) {
            url += "/" + ((function() {
              var l, len, ref, results;
              ref = _.flatten(state_description.exposed);
              results = [];
              for (l = 0, len = ref.length; l < len; l++) {
                component = ref[l];
                results.push(encodeURIComponent(component));
              }
              return results;
            })()).join("/");
          }
          if (state_description.buffer.length > 0) {
            url += "/-/" + ((function() {
              var l, len, ref, results;
              ref = _.flatten(state_description.buffer);
              results = [];
              for (l = 0, len = ref.length; l < len; l++) {
                component = ref[l];
                results.push(encodeURIComponent(component));
              }
              return results;
            })()).join("/");
          }
          if (_this.debug) {
            console.log('ROUTER: Calculated url:', url);
          }
          return url;
        };
      })(this);
      state_set_from_state_description = (function(_this) {
        return function(state_description, defer, replace) {
          var commit_needed_at, last_committed_state, new_state, previous_state, state_commit;
          state_commit = function(replace) {
            if (_this.debug) {
              console.log("ROUTER: Committing state:", _this.state_raw);
            }
            _this.state_raw.state_committed = true;
            session_data.object.states[_this.state_raw.state_id] = state_permanent(_this.state_raw);
            session_data.bump();
            if (commit_timer) {
              clearTimeout(commit_timer);
            }
            commit_scheduled_at = null;
            commit_timer = null;
            return location_update(replace);
          };
          commit_needed_at = Date.now() + defer;
          if (!_this.state_raw.state_committed) {
            last_committed_state = _this.state_raw.state_parent;
          } else {
            last_committed_state = _this.state_raw;
          }
          if (_this.debug) {
            console.log("ROUTER: Changing state. Commit deferred by", defer, "to be done at", commit_needed_at, " State before mutation:", last_committed_state);
          }
          previous_state = _this.state_raw;
          new_state = JSON.parse(JSON.stringify(state_permanent(_this.state_raw)));
          new_state = state_diff_apply(new_state, state_description.buffer);
          new_state = state_diff_apply(new_state, state_description.exposed);
          new_state = state_diff_apply(new_state, state_description.change);
          _.extend(new_state, _.pick(previous_state, function(value, key) {
            return key.indexOf("_") === 0;
          }));
          if (state_diff_generate(state_permanent(last_committed_state), state_permanent(new_state)).length > 0) {
            new_state.state_committed = false;
            if (previous_state.state_committed) {
              new_state.session_id = _this.session_id;
              new_state.state_id = _this.state_id++;
              new_state.state_parent = previous_state;
            } else {
              new_state.session_id = previous_state.session_id;
              new_state.state_id = previous_state.state_id;
              new_state.state_parent = previous_state.state_parent;
            }
          } else {
            new_state.session_id = last_committed_state.session_id;
            new_state.state_id = last_committed_state.state_id;
            new_state.state_parent = last_committed_state.state_parent;
            new_state.state_committed = last_committed_state.state_committed;
          }
          if (_this.filter != null) {
            _this.filter(new_state, previous_state);
          }
          _this.state_raw = new_state;
          _this.state = _this.cast(JSON.parse(JSON.stringify(_this.state_raw)));
          _this.state_valid = true;
          if (_this.state_raw.state_committed) {
            if (commit_timer) {
              clearTimeout(commit_timer);
            }
            commit_scheduled_at = null;
            commit_timer = null;
          } else {
            if (commit_needed_at <= Date.now()) {
              state_commit(replace);
            } else {
              location_update(false);
              if ((!commit_scheduled_at) || (commit_needed_at < commit_scheduled_at)) {
                if (_this.debug) {
                  console.log("ROUTER: Deferring commit by:", defer, "till", commit_needed_at);
                }
                _this.state_raw.state_committed = false;
                if (commit_timer) {
                  clearTimeout(commit_timer);
                }
                commit_scheduled_at = commit_needed_at;
                commit_timer = setTimeout((function() {
                  return state_commit(replace);
                }), commit_scheduled_at - Date.now());
              }
            }
          }
          if (_this.onchange != null) {
            return _this.onchange(_this.state_raw, previous_state);
          }
        };
      })(this);
      state_get_as_state_description = (function(_this) {
        return function(state) {
          var buffer, component, exposed, last_committed_state, pair;
          last_committed_state = state;
          while (last_committed_state.state_parent && ((!last_committed_state.session_id) || last_committed_state.session_id === _this.session_id) && ((session_data_saved.object.max_state_id || 0) < last_committed_state.state_id)) {
            last_committed_state = last_committed_state.state_parent;
          }
          if (_this.debug) {
            console.log('ROUTER: Last shareable state:', last_committed_state);
          }
          buffer = state_diff_generate(state_permanent(last_committed_state), state_permanent(state));
          exposed = (function() {
            var l, len, ref, results;
            ref = state_diff_generate({}, state);
            results = [];
            for (l = 0, len = ref.length; l < len; l++) {
              pair = ref[l];
              if (component = _.find(this.expose, function(component) {
                return component[0] === pair[0];
              })) {
                results.push([component[1], pair[1]]);
              }
            }
            return results;
          }).call(_this);
          buffer = (function() {
            var l, len, results;
            results = [];
            for (l = 0, len = buffer.length; l < len; l++) {
              pair = buffer[l];
              if (!_.find(this.expose, function(component) {
                return component[0] === pair[0];
              })) {
                results.push(pair);
              }
            }
            return results;
          }).call(_this);
          return {
            session_id: last_committed_state.session_id,
            state_id: last_committed_state.state_id,
            exposed: exposed,
            buffer: buffer,
            change: []
          };
        };
      })(this);
      location_update = (function(_this) {
        return function(new_history_entry) {
          var url;
          url = state_description_to_url(state_get_as_state_description(_this.state_raw));
          if (_this.debug) {
            console.log("ROUTER: Updating location:    state:", _this.state_raw, '    url:', url);
          }
          if (new_history_entry) {
            return window.history.pushState(_this.state_raw, null, url);
          } else {
            return window.history.replaceState(_this.state_raw, null, url);
          }
        };
      })(this);
      this.navigate = function(search, options) {
        var pathname, state_description;
        if (options == null) {
          options = {};
        }
        pathname = window.location.pathname;
        if (this.debug) {
          console.log('ROUTER: Navigating to:    pathname:', pathname, '    search:', search);
        }
        state_description = url_to_state_description(pathname, search);
        if (this.debug) {
          console.log('ROUTER: New state description:', state_description);
        }
        if (remote_state != null) {
          remote_state.unlink();
          remote_state = null;
        }
        if (state_description.session_id === this.session_id || state_description.state_id === "0") {
          return state_set_from_state_description(state_description, options.defer || 0, !options.replace);
        } else {
          this.state_valid = false;
          remote_state = this.seapig_client.slave('SeapigRouter::Session::' + state_description.session_id + '::State::' + state_description.state_id);
          return remote_state.onchange((function(_this) {
            return function() {
              if (!remote_state.valid) {
                return;
              }
              if (_this.debug) {
                console.log("ROUTER: Received remote state", remote_state.object);
              }
              _this.state_raw = JSON.parse(JSON.stringify(remote_state.object));
              _this.state_raw.state_committed = true;
              _this.state_raw.session_id = state_description.session_id;
              _this.state_raw.state_id = state_description.state_id;
              _this.state_raw.state_parent = void 0;
              state_set_from_state_description(state_description, options.defer || 0, !options.replace);
              remote_state.unlink();
              return remote_state = null;
            };
          })(this));
        }
      };
      this.volatile = function() {
        var data, key, ref, value;
        data = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        if (data.length === 1 && typeof data[0] === 'object') {
          ref = data[0];
          for (key in ref) {
            value = ref[key];
            this.state["_" + key] = value;
          }
          _.extend(this.state_raw, _.pick(this.state, function(value, key) {
            return key.indexOf("_") === 0;
          }));
          return window.history.replaceState(this.state_raw, null, window.location);
        } else {
          return _.object((function() {
            var l, len, results;
            results = [];
            for (l = 0, len = data.length; l < len; l++) {
              key = data[l];
              results.push([key, this.state["_" + key]]);
            }
            return results;
          }).call(this));
        }
      };
    }

    return SeapigRouter;

  })();

}).call(this);

//# sourceMappingURL=seapig-router.js.js.map
